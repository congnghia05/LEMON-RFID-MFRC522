{"MFRC522.ts":"/**\r\n  * MFRC522 Block\r\n  */\r\n//% color=\"#275C6B\" weight=100 icon=\"\\uf2bb\" block=\"MFRC522 RFID\"\r\nnamespace MFRC522 {\r\n    let Type2 = 0\r\n    const BlockAdr: number[] = [8, 9, 10]\r\n    let TPrescalerReg = 0x2B\r\n    let TxControlReg = 0x14\r\n    let PICC_READ = 0x30\r\n    let PICC_ANTICOLL = 0x93\r\n    let PCD_RESETPHASE = 0x0F\r\n    let temp = 0\r\n    let val = 0\r\n    let uid: number[] = []\r\n\r\n    let returnLen = 0\r\n    let returnData: number[] = []\r\n    let status = 0\r\n    let u = 0\r\n    let ChkSerNum = 0\r\n    let returnBits: any = null\r\n    let recvData: number[] = []\r\n    let PCD_IDLE = 0\r\n    let d = 0\r\n\r\n    let Status2Reg = 0x08\r\n    let CommandReg = 0x01\r\n    let BitFramingReg = 0x0D\r\n    let MAX_LEN = 16\r\n    let PCD_AUTHENT = 0x0E\r\n    let PCD_TRANSCEIVE = 0x0C\r\n    let PICC_REQIDL = 0x26\r\n    let PICC_AUTHENT1A = 0x60\r\n\r\n    let ComIrqReg = 0x04\r\n    let DivIrqReg = 0x05\r\n    let FIFODataReg = 0x09\r\n    let FIFOLevelReg = 0x0A\r\n    let ControlReg = 0x0C\r\n    let Key = [255, 255, 255, 255, 255, 255]\r\n    let address = 0x28\r\n\r\n    function i2cWrite(args: any[]): void {\r\n        let buffer = Buffer.create(0);\r\n\r\n        for (let arg of args) {\r\n            if (Array.isArray(arg)) {\r\n                buffer = buffer.concat(Buffer.fromArray(arg as number[]));\r\n            } else if (typeof arg === 'number') {\r\n                buffer = buffer.concat(Buffer.fromArray([arg as number]));\r\n            } else {\r\n                buffer = buffer.concat(arg as Buffer);\r\n            }\r\n        }\r\n\r\n        pins.i2cWriteBuffer(address, buffer);\r\n    }\r\n\r\n    function i2cReadUint8(): number {\r\n        return pins.i2cReadNumber(address, NumberFormat.UInt8LE);\r\n    }\r\n\r\n    function I2C_Read(adr: number) {\r\n        pins.i2cWriteNumber(address, adr, NumberFormat.UInt8LE);\r\n        return i2cReadUint8();\r\n    }\r\n\r\n    function SetBits(reg: number, mask: number) {\r\n        let tmp = I2C_Read(reg)\r\n        I2C_Write(reg, (tmp | mask))\r\n    }\r\n\r\n    function I2C_Write(adr: number, val: number) {\r\n        i2cWrite([adr, Buffer.pack('B', [val])]);\r\n    }\r\n\r\n    function readFromCard(): string {\r\n        let [status, Type2] = Request(PICC_REQIDL)\r\n        if (status != 0) {\r\n            return null, null\r\n        }\r\n\r\n        [status, uid] = AvoidColl()\r\n\r\n        if (status != 0) {\r\n            return null, null\r\n        }\r\n\r\n        let id = getIDNum(uid)\r\n        TagSelect(uid)\r\n        status = Authent(PICC_AUTHENT1A, 11, Key, uid)\r\n        let data: NumberFormat.UInt8LE[] = []\r\n        let text_read = ''\r\n        let block: number[] = []\r\n        if (status == 0) {\r\n            for (let BlockNum of BlockAdr) {\r\n                block = ReadRFID(BlockNum)\r\n                if (block) {\r\n                    data = data.concat(block)\r\n                }\r\n            }\r\n            if (data) {\r\n                for (let c of data) {\r\n                    text_read = text_read.concat(String.fromCharCode(c))\r\n                }\r\n            }\r\n        }\r\n        Crypto1Stop()\r\n        return text_read\r\n    }\r\n\r\n\r\n\r\n    function writeToCard(txt: string): number {\r\n        [status, Type2] = Request(PICC_REQIDL)\r\n\r\n        if (status != 0) {\r\n            return null, null\r\n        }\r\n        [status, uid] = AvoidColl()\r\n\r\n        if (status != 0) {\r\n            return null, null\r\n        }\r\n\r\n        let id = getIDNum(uid)\r\n        TagSelect(uid)\r\n        status = Authent(PICC_AUTHENT1A, 11, Key, uid)\r\n        ReadRFID(11)\r\n\r\n        if (status == 0) {\r\n            let data: NumberFormat.UInt8LE[] = []\r\n            for (let i = 0; i < txt.length; i++) {\r\n                data.push(txt.charCodeAt(i))\r\n            }\r\n\r\n            for (let j = txt.length; j < 48; j++) {\r\n                let space: number = 32;\r\n                data.push(space as NumberFormat.UInt8LE);\r\n\r\n            }\r\n\r\n            let b = 0\r\n            for (let BlockNum2 of BlockAdr) {\r\n                WriteRFID(BlockNum2, data.slice((b * 16), ((b + 1) * 16)))\r\n                b++\r\n            }\r\n        }\r\n\r\n        Crypto1Stop()\r\n        serial.writeLine(\"Written to Card\")\r\n        return id\r\n    }\r\n\r\n\r\n    function ReadRFID(blockAdr: number) {\r\n        recvData = []\r\n        recvData.push(PICC_READ)\r\n        recvData.push(blockAdr)\r\n        let pOut2 = []\r\n        pOut2 = CRC_Calculation(recvData)\r\n        recvData.push(pOut2[0])\r\n        recvData.push(pOut2[1])\r\n        let [status, returnData, returnLen] = MFRC522_ToCard(PCD_TRANSCEIVE, recvData)\r\n\r\n        if (status != 0) {\r\n            serial.writeLine(\"Error while reading!\")\r\n        }\r\n\r\n        if (returnData.length != 16) {\r\n            return null\r\n        }\r\n        else {\r\n            return returnData\r\n        }\r\n    }\r\n\r\n    function ClearBits(reg: number, mask: number) {\r\n        let tmp = I2C_Read(reg)\r\n        I2C_Write(reg, tmp & (~mask))\r\n    }\r\n\r\n\r\n\r\n    function Request(reqMode: number): [number, any] {\r\n        let Type: number[] = []\r\n        I2C_Write(BitFramingReg, 0x07)\r\n        Type.push(reqMode)\r\n        let [status, returnData, returnBits] = MFRC522_ToCard(PCD_TRANSCEIVE, Type)\r\n\r\n        if ((status != 0) || (returnBits != 16)) {\r\n            status = 2\r\n        }\r\n\r\n        return [status, returnBits]\r\n    }\r\n\r\n    function AntennaON() {\r\n        temp = I2C_Read(TxControlReg)\r\n        if (~(temp & 0x03)) {\r\n            SetBits(TxControlReg, 0x03)\r\n        }\r\n    }\r\n\r\n    function AvoidColl(): [number, number[]] {\r\n        let SerNum = []\r\n        ChkSerNum = 0\r\n        I2C_Write(BitFramingReg, 0)\r\n        SerNum.push(PICC_ANTICOLL)\r\n        SerNum.push(0x20)\r\n        let [status, returnData, returnBits] = MFRC522_ToCard(PCD_TRANSCEIVE, SerNum)\r\n\r\n        if (status == 0) {\r\n            if (returnData.length == 5) {\r\n                for (let k = 0; k <= 3; k++) {\r\n                    ChkSerNum = ChkSerNum ^ returnData[k]\r\n                }\r\n                if (ChkSerNum != returnData[4]) {\r\n                    status = 2\r\n                }\r\n            }\r\n            else {\r\n                status = 2\r\n            }\r\n        }\r\n        return [status, returnData]\r\n    }\r\n\r\n    function Crypto1Stop() {\r\n        ClearBits(Status2Reg, 0x08)\r\n    }\r\n\r\n\r\n    function Authent(authMode: number, BlockAdr: number, Sectorkey: number[], SerNum: number[]) {\r\n        let buff: number[] = []\r\n        buff.push(authMode)\r\n        buff.push(BlockAdr)\r\n        for (let l = 0; l < (Sectorkey.length); l++) {\r\n            buff.push(Sectorkey[l])\r\n        }\r\n        for (let m = 0; m < 4; m++) {\r\n            buff.push(SerNum[m])\r\n        }\r\n        [status, returnData, returnLen] = MFRC522_ToCard(PCD_AUTHENT, buff)\r\n        if (status != 0) {\r\n            serial.writeLine(\"AUTH ERROR!\")\r\n        }\r\n        if ((I2C_Read(Status2Reg) & 0x08) == 0) {\r\n            serial.writeLine(\"AUTH ERROR2!\")\r\n        }\r\n        return status\r\n    }\r\n\r\n    function MFRC522_ToCard(command: number, sendData: number[]): [number, number[], number] {\r\n        returnData = []\r\n        returnLen = 0\r\n        status = 2\r\n        let irqEN = 0x00\r\n        let waitIRQ = 0x00\r\n        let lastBits = null\r\n        let n = 0\r\n\r\n        if (command == PCD_AUTHENT) {\r\n            irqEN = 0x12\r\n            waitIRQ = 0x10\r\n        }\r\n\r\n        if (command == PCD_TRANSCEIVE) {\r\n            irqEN = 0x77\r\n            waitIRQ = 0x30\r\n        }\r\n\r\n        I2C_Write(0x02, irqEN | 0x80)\r\n        ClearBits(ComIrqReg, 0x80)\r\n        SetBits(FIFOLevelReg, 0x80)\r\n        I2C_Write(CommandReg, PCD_IDLE)\r\n\r\n        for (let o = 0; o < (sendData.length); o++) {\r\n            I2C_Write(FIFODataReg, sendData[o])\r\n        }\r\n        I2C_Write(CommandReg, command)\r\n\r\n        if (command == PCD_TRANSCEIVE) {\r\n            SetBits(BitFramingReg, 0x80)\r\n        }\r\n\r\n        let p = 2000\r\n        while (true) {\r\n            n = I2C_Read(ComIrqReg)\r\n            p--\r\n            if (~(p != 0 && ~(n & 0x01) && ~(n & waitIRQ))) {\r\n                break\r\n            }\r\n        }\r\n        ClearBits(BitFramingReg, 0x80)\r\n\r\n        if (p != 0) {\r\n            if ((I2C_Read(0x06) & 0x1B) == 0x00) {\r\n                status = 0\r\n                if (n & irqEN & 0x01) {\r\n                    status = 1\r\n                }\r\n                if (command == PCD_TRANSCEIVE) {\r\n                    n = I2C_Read(FIFOLevelReg)\r\n                    lastBits = I2C_Read(ControlReg) & 0x07\r\n                    if (lastBits != 0) {\r\n                        returnLen = (n - 1) * 8 + lastBits\r\n                    }\r\n                    else {\r\n                        returnLen = n * 8\r\n                    }\r\n                    if (n == 0) {\r\n                        n = 1\r\n                    }\r\n                    if (n > MAX_LEN) {\r\n                        n = MAX_LEN\r\n                    }\r\n                    for (let q = 0; q < n; q++) {\r\n                        returnData.push(I2C_Read(FIFODataReg))\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                status = 2\r\n            }\r\n        }\r\n\r\n        return [status, returnData, returnLen]\r\n    }\r\n\r\n    function TagSelect(SerNum: number[]) {\r\n        let buff: number[] = []\r\n        buff.push(0x93)\r\n        buff.push(0x70)\r\n        for (let r = 0; r < 5; r++) {\r\n            buff.push(SerNum[r])\r\n        }\r\n\r\n        let pOut = CRC_Calculation(buff)\r\n        buff.push(pOut[0])\r\n        buff.push(pOut[1])\r\n        let [status, returnData, returnLen] = MFRC522_ToCard(PCD_TRANSCEIVE, buff)\r\n        if ((status == 0) && (returnLen == 0x18)) {\r\n            return returnData[0]\r\n        }\r\n        else {\r\n            return 0\r\n        }\r\n    }\r\n\r\n    function CRC_Calculation(DataIn: number[]) {\r\n        ClearBits(DivIrqReg, 0x04)\r\n        SetBits(FIFOLevelReg, 0x80)\r\n        for (let s = 0; s < (DataIn.length); s++) {\r\n            I2C_Write(FIFODataReg, DataIn[s])\r\n        }\r\n        I2C_Write(CommandReg, 0x03)\r\n        let t = 0xFF\r\n\r\n        while (true) {\r\n            let v = I2C_Read(DivIrqReg)\r\n            t--\r\n            if (!(t != 0 && !(v & 0x04))) {\r\n                break\r\n            }\r\n        }\r\n\r\n        let DataOut: number[] = []\r\n        DataOut.push(I2C_Read(0x22))\r\n        DataOut.push(I2C_Read(0x21))\r\n        return DataOut\r\n    }\r\n\r\n    function WriteRFID(blockAdr: number, writeData: number[]) {\r\n        let buff: number[] = []\r\n        let crc: number[] = []\r\n\r\n        buff.push(0xA0)\r\n        buff.push(blockAdr)\r\n        crc = CRC_Calculation(buff)\r\n        buff.push(crc[0])\r\n        buff.push(crc[1])\r\n        let [status, returnData, returnLen] = MFRC522_ToCard(PCD_TRANSCEIVE, buff)\r\n        if ((status != 0) || (returnLen != 4) || ((returnData[0] & 0x0F) != 0x0A)) {\r\n            status = 2\r\n            serial.writeLine(\"ERROR\")\r\n        }\r\n\r\n        if (status == 0) {\r\n            let buff2: number[] = []\r\n            for (let w = 0; w < 16; w++) {\r\n                buff2.push(writeData[w])\r\n            }\r\n            crc = CRC_Calculation(buff2)\r\n            buff2.push(crc[0])\r\n            buff2.push(crc[1])\r\n            let [status, returnData, returnLen] = MFRC522_ToCard(PCD_TRANSCEIVE, buff2)\r\n            if ((status != 0) || (returnLen != 4) || ((returnData[0] & 0x0F) != 0x0A)) {\r\n                serial.writeLine(\"Error while writing\")\r\n            }\r\n            else {\r\n                serial.writeLine(\"Data written\")\r\n            }\r\n        }\r\n    }\r\n\r\n    function getIDNum(uid: number[]) {\r\n        let a = 0\r\n\r\n        for (let e = 0; e < 5; e++) {\r\n            a = a * 256 + uid[e]\r\n        }\r\n        return a\r\n    }\r\n\r\n    function readID() {\r\n        [status, Type2] = Request(PICC_REQIDL)\r\n\r\n        if (status != 0) {\r\n            return null\r\n        }\r\n        [status, uid] = AvoidColl()\r\n\r\n        if (status != 0) {\r\n            return null\r\n        }\r\n\r\n        return getIDNum(uid)\r\n    }\r\n\r\n    /*\r\n     * Initial setup\r\n     */\r\n    //% block=\"Initialize MFRC522 Module\"\r\n    //% weight=100\r\n    export function Init() {\r\n        // reset module\r\n        I2C_Write(CommandReg, PCD_RESETPHASE)\r\n\r\n        I2C_Write(0x2A, 0x8D)\r\n        I2C_Write(0x2B, 0x3E)\r\n        I2C_Write(0x2D, 30)\r\n        I2C_Write(0x2E, 0)\r\n        I2C_Write(0x15, 0x40)\r\n        I2C_Write(0x11, 0x3D)\r\n        AntennaON()\r\n    }\r\n\r\n    /*\r\n     * Function to read ID from card\r\n     */\r\n    //% block=\"Read ID\"\r\n    //% weight=95\r\n    export function getID() {\r\n        let id = readID()\r\n        while (!(id)) {\r\n            id = readID()\r\n            if (id != undefined && id >= 100000000000) {\r\n                return id\r\n            }\r\n        }\r\n        serial.writeLine(\"Card ID: \" + id)\r\n        return id\r\n    }\r\n\r\n    /*\r\n     * Function to read Data from card\r\n     */\r\n    //% block=\"Read data\"\r\n    //% weight=90\r\n    export function read(): string {\r\n        let text = readFromCard()\r\n        while (!text) {\r\n            let text = readFromCard()\r\n\r\n            if (text != '') {\r\n                return text\r\n            }\r\n        }\r\n        return text\r\n    }\r\n\r\n\r\n\r\n\r\n    /*\r\n     * Function to write Data\r\n     */\r\n    //% block=\"Write Data %text\"\r\n    //% text\r\n    //% weight=85\r\n    export function write(text: string) {\r\n        let id = writeToCard(text)\r\n\r\n        while (!id) {\r\n            let id = writeToCard(text)\r\n\r\n            if (id != undefined) {\r\n                return\r\n            }\r\n        }\r\n        return\r\n    }\r\n\r\n    /*\r\n     * TUrn off antenna\r\n     */\r\n    //% block=\"Turn off antenna\"\r\n    //% text\r\n    //% weight=80\r\n    export function AntennaOff() {\r\n        ClearBits(TxControlReg, 0x03)\r\n    }\r\n\r\n}\r\n","README.md":"\r\n## Initialize RFID module\r\n\r\nThe RFID module needs to be initialized before it is ready to use. All necessary commands will be transfered via SPI here.\r\n\r\n```typescript\r\n// Initialize RIFD module\r\nMFRC522.Init()\r\n```\r\n\r\n## Read ID from card\r\n\r\nThis function reads the cards unique ID and returns it.\r\n\r\n```typescript\r\n// Read unique ID\r\nMFRC522.getID()\r\n```\r\n\r\n## Read data from card\r\n\r\nData stored on the card can be retrieved with this function.\r\n\r\n```typescript\r\n// Read data\r\nMFRC522.read()\r\n```\r\n\r\n## Write data to card\r\n\r\nWrite data, formatted as string, to the card.\r\n\r\n```typescript\r\n// Write data\r\nMFRC522.write(\"1234\")\r\n```\r\n\r\n## Turn off antenna\r\n\r\nAfter use, the antenn can be turned off.\r\n\r\n```typescript\r\n// Turn antenna off\r\nMFRC522.AntennaOff()\r\n```\r\n\r\n## Supported targets\r\n\r\n* for PXT/microbit\r\n\r\n## License\r\n\r\nMIT\r\n","_locales/zh/pxt-mfrc522-jsdoc-strings.json":"{}","_locales/zh/pxt-mfrc522-strings.json":"{\n  \"MFRC522.AntennaOff|block\": \"关闭天线\",\n  \"MFRC522.Init|block\": \"初始化RFID模块\",\n  \"MFRC522.getID|block\": \"读取卡号\",\n  \"MFRC522.read|block\": \"读取数据\",\n  \"MFRC522.write|block\": \"写入数据 %text\",\n  \"{id:category}MFRC522\": \"MFRC522\"\n}","pxt.json":"{\n    \"name\": \"pxt-mfrc522\",\n    \"version\": \"1.0.0\",\n    \"description\": \"MakeCode package for the MFRC522 RFID module.\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"MFRC522.ts\",\n        \"_locales/zh/pxt-mfrc522-jsdoc-strings.json\",\n        \"_locales/zh/pxt-mfrc522-strings.json\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"4.0.11\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// Initialize RFID module\r\nMFRC522.Init();\r\nserial.writeLine(\"RFID module initialized\");\r\nbasic.forever(function () {\r\n\r\n    serial.writeLine(MFRC522.getID().toString());\r\n})\r\n// Get ID of RFID card\r\n\r\n\r\n// Read data from RFID card\r\n// serial.writeLine(MFRC522.read());\r\n\r\n// Write data to card\r\n// MFRC522.write(\"1234\")\r\n\r\n// Turn off antenna\r\n// MFRC522.AntennaOff()"}